#include "fsl_debug_console.h"
#include "fsl_adc16.h"
#include "board.h"
#include "fsl_common.h"
#include "pin_mux.h"
#include <math.h>

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define DEMO_ADC16_BASE ADC0
#define DEMO_ADC16_CHANNEL_GROUP 0U
#define DEMO_ADC16_USER_CHANNEL 8U  // Choose your channel based on connection

#define SERIES_RESISTOR 100000.0      // 100kΩ fixed resistor
#define NOMINAL_RESISTANCE 100000.0   // 100kΩ at 25°C
#define NOMINAL_TEMPERATURE 25.0      // 25°C
#define BETA_COEFFICIENT 3950.0       // Adjust based on your thermistor spec
#define ADC_MAX 65535.0               // 16-bit ADC
#define VREF 3.3                     // Reference voltage (typically 3.3V)

/*******************************************************************************
 * Prototypes
 ******************************************************************************/
double Thermistor(uint16_t adc_value);

/*******************************************************************************
 * Code
 ******************************************************************************/
double Thermistor(uint16_t adc_value)
{
    double v_in = (adc_value / ADC_MAX) * VREF;
    double resistance = SERIES_RESISTOR * (v_in / (VREF - v_in));

    double steinhart = resistance / NOMINAL_RESISTANCE;     // (R/R0)
    steinhart = log(steinhart);                             // ln(R/R0)
    steinhart /= BETA_COEFFICIENT;                          // 1/B * ln(R/R0)
    steinhart += 1.0 / (NOMINAL_TEMPERATURE + 273.15);      // + (1/To)
    steinhart = 1.0 / steinhart;                            // Invert to Kelvin
    steinhart -= 273.15;                                    // Convert to Celsius

    return steinhart;
}

int main(void)
{
    adc16_config_t adc16ConfigStruct;
    adc16_channel_config_t adc16ChannelConfigStruct;

    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitDebugConsole();

    PRINTF("\r\nADC16 polling example with 100k thermistor.\r\n");

    /*
     * adc16ConfigStruct.referenceVoltageSource = kADC16_ReferenceVoltageSourceVref;
     * adc16ConfigStruct.clockSource = kADC16_ClockSourceAsynchronousClock;
     * adc16ConfigStruct.enableAsynchronousClock = true;
     * adc16ConfigStruct.clockDivider = kADC16_ClockDivider8;
     * adc16ConfigStruct.resolution = kADC16_ResolutionSE16Bit;
     * adc16ConfigStruct.longSampleMode = kADC16_LongSampleDisabled;
     */
    ADC16_GetDefaultConfig(&adc16ConfigStruct);
    adc16ConfigStruct.resolution = kADC16_ResolutionSE16Bit;  // Set 16-bit resolution
    adc16ConfigStruct.referenceVoltageSource = kADC16_ReferenceVoltageSourceVref;  // Use external VREF (typically 3.3V)
    ADC16_Init(DEMO_ADC16_BASE, &adc16ConfigStruct);
    ADC16_EnableHardwareTrigger(DEMO_ADC16_BASE, false);  // Software trigger

    adc16ChannelConfigStruct.channelNumber = DEMO_ADC16_USER_CHANNEL;
    adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
#if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
    adc16ChannelConfigStruct.enableDifferentialConversion = false;
#endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */

    while (1)
    {
        ADC16_SetChannelConfig(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP, &adc16ChannelConfigStruct);
        while (0U == (kADC16_ChannelConversionDoneFlag &
                      ADC16_GetChannelStatusFlags(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP)))
        {
        }
        uint16_t adcValue = ADC16_GetChannelConversionValue(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP);

        double temperatureC = Thermistor(adcValue);

        PRINTF("ADC Value: %5d  →  Temperature: %.2f °C\r\n", adcValue, temperatureC);


    }
}
