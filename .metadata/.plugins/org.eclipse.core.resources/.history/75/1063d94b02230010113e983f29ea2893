/**
 * @file    main.c
 * @brief   Application entry point for the Battery Management System (BMS).
 *
 * @details This file initializes the MCU, peripherals, and BMS modules, then enters
 *          the main loop to handle periodic measurement updates, fault monitoring,
 *          and safety actions (e.g., opening SSR on fault detection).
 *
 * @note Project: Graduation Project - Battery Management System
 * @note Engineer: Abdullah Mohamed
 * @note Dependencies: Relies on FuSa, DataBase, SlaveIF, DebugInfo,Battery status Monitor,CB Manager,
 *  Charging Manager, ScreenIF and Temp Manager modules.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 * Copyright 2016-2025 NXP. All rights reserved.
 */

// --- Needed library --- //
#include "stdio.h"
#include "string.h"

// --- Platform/MCU Specific Includes --- //
#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "fsl_clock.h"
#include "fsl_gpio.h"
#include "fsl_pit.h"
#include "fsl_device_registers.h"

// --- External Dependencies --- //
#include <COTS/BMSDataBase/Inc/DataBase.h>
#include <COTS/BatteryStatusMonitor/Inc/DataMonitor.h>
#include <COTS/ChargingManager/Inc/ChargingManager.h>

// --- Global variables for ISR flags --- //
extern volatile bool data_interrupt;
extern volatile bool fault_interrupt;
extern volatile uint32_t systick_count;

// --- Static Variables --- //
static bool isCircuitDisconnected = false; // Tracks SSR state to avoid redundant calls

// --- Main Application Entry Point --- //
int main(void)
{
	/////////////////////////////////////////////////////////////////////////////////////////////////
	/* ========================= --- 1. MCU and Board Initialization --- ========================= */
	/////////////////////////////////////////////////////////////////////////////////////////////////
	BOARD_InitBootPins();
	BOARD_InitBootClocks();
	BOARD_InitBootPeripherals(); // Initializes peripherals configured by MCUXpresso
#ifndef BOARD_INIT_DEBUG_CONSOLE_PERIPHERAL
	BOARD_InitDebugConsole(); // Initialize debug console for PRINTF
#endif
	PRINTF("Board Initialized.\n\r\r");

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 2. GPIO Initialization (LEDs and CS) ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	gpio_pin_config_t led_config = {kGPIO_DigitalOutput, 0}; // Output, initial state low

	GPIO_PinInit(GPIOB, 19U, &led_config);									 // Green LED
	GPIO_PinInit(BOARD_LED_BLUE_GPIO, BOARD_LED_BLUE_GPIO_PIN, &led_config); // Blue LED
	PRINTF("Status LEDs and CS Initialized.\n\r\r");

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 3. Peripheral Initialization ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	I2C_init(); // Initialize I2C for LCD or other peripherals
	PRINTF("I2C Initialized.\n\r\r");

	SysTick_Init();
	FuSa_configure_systick(); // Configure SysTick for 100ms interval
	PRINTF("SysTick Initialized. Core frequency: %u Hz\n\r", CLOCK_GetCoreSysClkFreq());

	SlaveIF_initTransfer(); // Initialize SPI and DMA handles
	SlaveIF_tplEnable();	// Enable MC33664 TPL
	SlaveIF_wakeUp();		// Wake up MC33771B
	PRINTF("SPI Master Initialized.\n\r\r");

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 4. MC33771B Slave Initialization ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	PRINTF("Configuring MC33771B Slave Device...\n\r\r");
	if (SlaveIF_init())
		PRINTF("MC33771B Basic Configuration Complete.\n\r\r");
	else
		PRINTF("MC33771B Basic Configuration Failed!\n\r\r");

	if (SlaveIF_configureProtectionThresholds())
		PRINTF("MC33771B Thresholds Configuration Complete.\n\r\r");
	else
		PRINTF("MC33771B Thresholds Configuration Failed!\n\r\r");

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 5. Application Data Initialization ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	MeasurementData currentData, previousData;
	FaultData currentFaults, previousFaults;
	DataBase_Init(); // Initialize measurement database
	FuSa_Init();	 // Initialize functional safety supervisor

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 6. Initial Data Acquisition ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	PRINTF("Performing initial data acquisition...\n\r\r");
	SlaveIF_startMeasurementCycle();				  // Trigger initial measurement
	DataBase_UpdateMeasurementData();				  // Update measurements
	DataBase_GetCurrentMeasurementData(&currentData); // Get initial data
	FuSa_updateFaultData();							  // Update fault status
	FuSa_getCurrentFaultData(&currentFaults);		  // Get initial fault status
	// DataMonitor_lcd(59, 100, 0.25, 25.6, 1, 0);         // Update LCD with initial data
	PRINTF("Initial Data Acquisition Complete.\n\r\r");

	/////////////////////////////////////////////////////////////////////////////////////////////
	/* ==================== 7. Main Application Loop ==================== */
	/////////////////////////////////////////////////////////////////////////////////////////////
	PRINTF("Setup Complete. Entering main application loop.\n\r\r");
	while (1)
	{
		__enable_irq;
		// Task 1: Handle Data Update (every 5 seconds, triggered by SysTick)
		if (data_interrupt)
		{
			data_interrupt = false;							   // Clear flag
			DataBase_GetCurrentMeasurementData(&previousData); // Store previous data
			SlaveIF_startMeasurementCycle();				   // Trigger new measurement
			DataBase_UpdateMeasurementData();				   // Update measurements
			DataBase_GetCurrentMeasurementData(&currentData);  // Get new data
			// Update LCD or other outputs
			// DataMonitor_lcd(currentData.SOC, currentData.SOH, currentData.Current, ...);
		}

		// Task 2: Handle Fault Update (every 1 second, triggered by SysTick)
		if (fault_interrupt)
		{
			fault_interrupt = false;				   // Clear flag
			FuSa_getCurrentFaultData(&previousFaults); // Store previous faults
			SlaveIF_startMeasurementCycle();		   // Trigger new measurement
			FuSa_updateFaultData();					   // Update fault status
			FuSa_getCurrentFaultData(&currentFaults);  // Get new fault status

			// Check for any fault and take action
			if (!isCircuitDisconnected &&
					(currentFaults.rawFault1Status || currentFaults.rawFault2Status || currentFaults.rawFault3Status ||
							currentFaults.overVoltageFlags || currentFaults.underVoltageFlags ||
							currentFaults.overtemperatureFlags || currentFaults.undertemperatureFlags ||
							currentFaults.gpioShortFlags || currentFaults.anOpenLoadFlags ||
							currentFaults.cbShortFlags || currentFaults.cbOpenFlags))
			{
				ChargingManager_ssrOpen(true);										  // Open SSR to disconnect battery
				isCircuitDisconnected = true;										  // Update state
				DebugInfo_PrintFaultReason(&currentFaults);							  // Print detailed fault reason
				GPIO_WritePinOutput(BOARD_LED_BLUE_GPIO, BOARD_LED_BLUE_GPIO_PIN, 1); // Indicate fault with LED
			}
		}

		// Task 3: Other Non-Blocking Tasks
		// Example: Handle UI inputs, run state machine, or send data over CAN
		// if (user_input) { /* Process input */ }

		// Task 4: Low-Power Mode
		if (!data_interrupt && !fault_interrupt)
		{
			__WFI(); // Wait for interrupt to reduce power consumption
		}
	}

	return 0; // Unreachable
}

//=============================================================================
// End of File
//=============================================================================
