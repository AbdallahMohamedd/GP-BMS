#include "fsl_debug_console.h"
#include "fsl_adc16.h"
#include "board.h"
#include "fsl_common.h"
#include "pin_mux.h"
#include <math.h>

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define DEMO_ADC16_BASE ADC0
#define DEMO_ADC16_CHANNEL_GROUP 0U
//#define DEMO_ADC16_USER_CHANNEL 9U  // Choose your channel based on connection

#define SERIES_RESISTOR 100000.0      // 100kΩ fixed resistor
#define NOMINAL_RESISTANCE 100000.0   // 100kΩ at 25°C
#define NOMINAL_TEMPERATURE 25.0      // 25°C
#define BETA_COEFFICIENT 3950.0       // Adjust based on your thermistor spec
#define ADC_MAX 65535.0               // 16-bit ADC
#define VREF 5                     // Reference voltage (typically 3.3V)

/*******************************************************************************
 * Prototypes
 ******************************************************************************/
double Thermistor(uint16_t adc_value);

/*******************************************************************************
 * Code
 ******************************************************************************/
double Thermistor(uint16_t adc_value)
{
    double v_in = (adc_value / ADC_MAX) * VREF;
    double resistance = SERIES_RESISTOR * (v_in / (VREF - v_in));

    double steinhart = resistance / NOMINAL_RESISTANCE;     // (R/R0)
    steinhart = log(steinhart);                             // ln(R/R0)
    steinhart /= BETA_COEFFICIENT;                          // 1/B * ln(R/R0)
    steinhart += 1.0 / (NOMINAL_TEMPERATURE + 273.15);      // + (1/To)
    steinhart = 1.0 / steinhart;                            // Invert to Kelvin
    steinhart -= 273.15;                                    // Convert to Celsius

    return steinhart;
}
void ADC_Init(void)
{
    adc16_config_t adc16ConfigStruct;

    ADC16_GetDefaultConfig(&adc16ConfigStruct);
    adc16ConfigStruct.resolution = kADC16_ResolutionSE16Bit;
    adc16ConfigStruct.referenceVoltageSource = kADC16_ReferenceVoltageSourceVref;  // External Vref (3.3V typical)
    ADC16_Init(DEMO_ADC16_BASE, &adc16ConfigStruct);
    ADC16_EnableHardwareTrigger(DEMO_ADC16_BASE, false);  // Software trigger
}
uint16_t ADC_Read(uint32_t channel)
{
    adc16_channel_config_t adc16ChannelConfigStruct = {0};
    adc16ChannelConfigStruct.channelNumber = channel;
    adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;

#if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
    adc16ChannelConfigStruct.enableDifferentialConversion = false;
#endif

    ADC16_SetChannelConfig(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP, &adc16ChannelConfigStruct);

    while (0U == (kADC16_ChannelConversionDoneFlag &
                  ADC16_GetChannelStatusFlags(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP)))
    {
    }

    return ADC16_GetChannelConversionValue(DEMO_ADC16_BASE, DEMO_ADC16_CHANNEL_GROUP);
}

int main(void)
{


    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitDebugConsole();

    PRINTF("\r\nADC16 polling example with 100k thermistor.\r\n");

    ADC_Init();

    while (1)
    {

        uint16_t adcValue = ADC_Read(9);

        double temperatureC = Thermistor(adcValue);

        PRINTF("ADC Value: %5d  →  Temperature: %.2f °C\r\n", adcValue, temperatureC);

}
}
